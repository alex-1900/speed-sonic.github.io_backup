---
layout: post
title:  "Mysql 索引覆盖和延迟关联"
date:   2020-02-18 18:59:32 +0800
# modified_date: 2020-02-19 21:51:20 +0800
categories: 数据库 后端
tags: mysql 性能
---
索引覆盖和延迟关联是 Mysql 查询的优化技巧，在应用程序需要扫描大量数据时发挥作用，本文记录这两种方法的原理与使用案例。

## 索引与 B+Tree
我们知道，BTree 是 Mysql 中很常用的的索引类型，实际上，BTree 索引是 B+Tree 的一种实现，与 BTree 是有区别的。

与 BTree 不同，B+Tree 的`非叶子节点`的关键字中不保存数据，仅包含指向其子树的指针（BTree 的每个关键字都是包含数据的），所以在查找过程中，遇到相匹配的`非叶子节点`时，并不停止，而是继续沿指针向下，直到最终遇到`叶节点`为止。而叶节点中包含了全部关键字，并根据关键字大小顺序连接，形成链表结构。

B+Tree 与 BTree 相比更适合数据库场景，因为 B+Tree 的磁盘页可以容纳更多的节点（因为是索引节点，比较小）；B+Tree 也更加适合范围查找，因为 B+Tree 只要遍历叶节点组成的链表即可，而 BTree 则需要进行`中序遍历`。

## 聚簇索引与非聚簇索引
Mysql 的 Innodb 引擎使用了`聚簇索引`，而 Myisam 引擎使用的是`非聚簇索引`。它们的区别在于，聚簇索引的叶子节点就是数据节点（数据行）；而非聚簇索引的叶子节点是一个索引节点，包含了指向数据节点的指针。`聚簇索引`的数据访问速度通常要比`非聚簇索引`快一些。

Innodb 的主键索引就是一个`聚簇索引`，主索引的叶子节点也是数据节点，这就是为什么 Innodb 引擎必须建立主键的原因。由于数据节点位于主键上，所以`二级索引`（非主键）的叶子节点只能指向自己对应的主键的关键字了。当我们用`二级索引`做查询时，首先扫描`二级索引`，查出主键值，然后再到`主键索引`上进行扫描，可以说是扫描了两次。Myisam 引擎与 Innodb 不同，它的主键索引与二级索引没有任何区别，它们都是索引节点，指向对应的数据节点。

## 索引覆盖 VS 随机I/O
Mysql 在执行查询时，会从`聚簇索引`的叶子节点中取出整行数据，然后进行数据筛选，我们把取数据这一操作称为`回表`。`回表`操作无疑会产生磁盘的随机 I/O，如果一次查询产生过多的回表操作，就会对系统性能产生较大的影响。

一个有效避免回表的方法，就是索引覆盖（covering indexes），它的原理是，因为索引的叶子节点本身包含了数据，所以如果使用的索引，涵盖了查询语句中涉及的所有字段，就可以直接从索引中得到数据，而不需要回表了。在执行查询之前，Mysql 的优化器会分析当前的 SQL 是否能够使用索引覆盖，据此制定执行计划。

看一个例子，下面是一个关于图书信息的查询，我们先建立 (`id`,`authorId`,`title`) 的索引，然后执行查询：
```sql
SELECT id, authorId FROM books WHERE `title` LIKE 'Mysql%';
```

由于索引覆盖了所有相关字段，所以这一查询没有产生回表操作，有效避免了随机 I/O。

索引覆盖技术是指 Mysql 使用索引直接获取数据，而不需要读取数据行，这一点在 Innodb 引擎中尤其有效，因为使用`二级索引`需要做两次扫描，如果能够利用索引覆盖，性能提升的幅度是很大的。

## 什么情况下无法使用索引覆盖
- 对所有列的查询。因为没有任何索引能够覆盖所有列。
- Mysql 无法对以通配符开头的 LIKE 语句使用索引。但可以使用左前缀匹配的 LIKE 操作，因为该操作可以转化为比较计算。

## 延迟关联
我们希望程序尽可能的使用索引覆盖，但在很多场景下是无法做到的，我们的业务逻辑通常需要获取所有数据。在这种情况下，我们仍然可以利用索引覆盖技术，将查询范围缩减到最小。

一个经典的场景是分页查询。如下例所示，我们希望查询 100000 条之后的 10 条图书信息：
```sql
SELECT * FROM books WHERE `title` LIKE '%Mysql%' LIMIT 100000, 10;
```

这条 sql 语句，会让 mysql 从数据节点中取出 100010 条数据，然后抛弃前 100000 条，也就是`回表` 100010 次，这种程度的随机 I/O 会让查询变得异常缓慢！所以，我们将查询语句改造一下：
```sql
SELECT * FROM books JOIN (
    SELECT id FROM books WHERE `title` LIKE '%Mysql%' LIMIT 100000, 10
) AS t1 ON (t1.id = books.id);
```

观察上面的 SQL，我们在 JOIN 子句中的查询利用了索引覆盖，将原来的 100010 条数据缩减为 10 条，`SELECT *` 仅产生了 10 次随机 I/O。

我们将这种技巧称为`延迟关联`，当我们遇到无法使用索引覆盖整个查询的情况时，就可以利用这个技巧规避一部分的回表操作。